function result = demix(v, t, w1, w2, smooth)
% Demix time sequence into a time-modulated sum of sins.
% Specifically, for a signal v(t), assumed to be a mixture of the form:
%   v(t) = a0(t) + a1(t)*sin(w1*t + p1(t)) + a2(t)*sin(w2*t + p2(t))
% Finds the time-varying amplitudes {a0,a1,a2} and phases {p1,p2}, under
% the assumption that they are varying slower than max(w1,w2).
% INPUT:
%   v, t - signal and time vectors to demix
%   w1, w2 - frequency of the underlying sins
%   smooth - bool, smooth params between pointwise solutions? default=true
% OUTPUT:
%   struct with esimated parameters.

if ~exist('smooth', 'var'), smooth = true; end

v = v(:);
t = t(:);

A = [ones(size(t)), sin(w1*t), cos(w1*t), sin(w2*t), cos(w2*t)];
x = nan(size(A));
for i = 3:(size(A,1)-2)
    ifm = min([1, i - 5]);
    ito = max([1, size(A,1)-2]);
    ii = i + (-2:2);
    x(i, :) = pinv(A(ii, :)) * v(ii);
end

x(1:2,:) = x([3,3],:);
x(end-1:end,:) = x([end-2, end-2],:);
x = x';

%x = smoothdata(x, 2, "gaussian", 51);

result = struct();
result.a0 = x(1, :);
result.a1 = sqrt(x(2,:).^2 + x(3,:).^2);
result.p1 = atan2(x(3,:), x(2,:));
result.a2 = sqrt(x(4,:).^2 + x(5,:).^2);
result.p2 = atan2(x(5,:), x(4,:));
result.w1 = w1;
result.w2 = w2;


%Fs = round(length(t)/(t(end) - t(1)));
%fpass = 5;
%result.p1 = lowpass(result.p1, fpass, Fs);
%result.p2 = lowpass(result.p2, fpass, Fs);
%r = round(2 * pi / w1 / 8 * Fs);
%result.p1 = smoothdata(result.p1, "movmean", r);
%r = round(2 * pi / w2 / 8 * Fs);
%result.p2 = smoothdata(result.p2, "movmean", r);

% if smooth
%     flds = setdiff(fieldnames(result), {'w1', 'w2'});
%     for iFld = 1 : length(flds)
%          result.(flds{iFld}) = smoothdata(result.(flds{iFld}), "movmean", 2 * 5 + 1);
%     end
% end